AADL BEHAVIOR ANNEX 2.13 - RULES TO CHECK AND COMMENTS

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
RULES
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
SEMANTIC RULES
--------------------------------------------------------------------------------

.behavior annex subclause/specification
-------------------------------------------
- X.3.(2) in modes, all modes > nothing to do
- X.3.(20) annex subclause and aadl core language consistency
- X.3.(21) subprogram, thread, subprogram call sequences and behavior annex subclause

.automaton
-------------------------------------------
#subprograms
- X.3.(8) subprogram states automaton  (DONE & CHECKED) 
- X.3.(12) modes and subprograms       (NYI)

#components
- X.3.(13) components and modes  (NYI)
- X.3.(23) behavior specification (DONE & UNCHECKED, group with X.3.(10) X.3.(9) & X.3.(22)
- X.4.(1) consistency between aadl core port frozen... (NYI)

(IMPORTANT RESTORE THREAD AND DEVICE, AND OTHER COMPONENTS)

.states
-------------------------------------------
- X.3.(11) final state cannot accept outgoing transitions (DONE & CHECKED)


.variables
-------------------------------------------
- X.3.(27) local var must be typed with valid data component classifier (DONE & CHECKED)
- X.3.(28) if persistent var, not oblige to have data subcomp (DONE group with X.3.(27))
(??check with aadl forum)

.transitions
-------------------------------------------
- X.3.(15) transitions and conditions       (DONE & UNCHECKED)
- X.3.(18) transitions and priority numbers (NOTHING TO DO)
- X.3.(19) transitions and actions          (NOTHING TO DO)

(a partir de la rechecker les core aadl language des regles au dessus)

.conditions
-------------------------------------------
- X.3.(16) dispatch conditions (DONE partially & CHECKED)
- X.3.(17) execute conditions (DONE partially & CHECKED)
- X.3.(24) dipatch conditions refinement (DONE partially improve property in component type & CHECKED)
- X.3.(25) dispatch condition, priority (NOTHING TO DO)
- X.3.(26) timeout dispatch condition, Period property (DONE & CHECKED)

- X.4.(2) dipatch condition, transition, out complete state (DONE, CHECKED, group with X.3.(16))
- X.4.(3) dispatch condition, timeout et aadl core language (DONE UNCHECKED, group with X.3.(26))
- X.4.(4) dispatch condition, transition, complete and final state NYI
          aadl core language
- X.4.(5) dispatch condition, event data dispatch trigger (DONE, CHECKED). Same as legality rule
          X.4(12). Implemented.
- X.4.(6) dispatch trigger, numeral, ormore, orless  (DONE, CHECKED) >> need to be verify with aadl committee


.ports
-------------------------------------------
- X.5.(6) ports, input_time property, output_time, aadl consistency NOTHING TO DO
- X.5.(7)  NOTHING TO DO what is with statement ?
- X.5.(13) output out or in out ports, data access features, incoming parameter (DONE & CHECKED)
- X.5.(15) send, receive output on ports


.data components
-------------------------------------------
- X.5.(11) shared data, concurrency control protocol
- X.5.(12) shared data, concurrency control protocol, 3 sc


.subprograms
-------------------------------------------
- X.5.(18)
- X.5.(19)
- X.5.(20) nothing to implement

.basic actions
-------------------------------------------
- X.6.(3) assignment action target references in assignments
- X.6.(4) communication actions ports parameters subprogram calls
- X.6.(5) timed actions and computation
- X.6.(6) timed actions and time values and aadl core language properties

.assignment actions
-------------------------------------------
- X.6.(15) out and assignment actions
- X.6.(16) assignment actions re-used in same action sets
- X.6.(17) target, expressions matching types

.timed actions
-------------------------------------------
- X.6.(18) timed actions cannont be used in action sets
- X.6.(19) computation

.timeout
-------------------------------------------
- X.6.(7) timeout and execution block

.behavior expressions
-------------------------------------------
- X.7.(1) voir avec seb
- X.7.(2) voir avec seb
- X.7.(3) voir avec seb
- X.7.(4) voir avec Ada ref manual


--------------------------------------------------------------------------------
LEGALITY RULES
--------------------------------------------------------------------------------

.conditions
-------------------------------------------
- X.4.(L12) dispatch trigger condition, event data port and value others. Same
            as semantic rule X.4.(5). Implemented.


.timeout
-------------------------------------------
- X.4.(L13) timeout value, aadl core language property


.assignment actions
-------------------------------------------
- X.6.(14) type of target and expression must match. Same as semantic rule X.6(17). 
            Not implemented.
- X.6.(15) element_variable_identifier of for control struct is not a target
- X.6.(16) action set and local variable
- X.6.(17) action set and port variable


.timed actions
-------------------------------------------
- X.6.(21) computation max >= min


.subprogram
-------------------------------------------
- X.6.(18) parameter list and subprogram signature must match
[SEB]- X.3.(L1) subprogram must not define persistent variables
[SEB]- X.3.(L3) subprogram must define an initial state and one final state 
[SEB]- X.3.(L4) subprogram must not define any complete states
[SEB]- X.3.(L7) subprogram must not contain a dispatch condition in any of its transitions 


.thread and devices
-------------------------------------------
[SEB]- X.3.(L5) suspendable components must define one complete state and one initial state.
[SEB]- X.3.(L6) component with initialization and finalization entrypoints may
                include one initial state and one or more final states

.ports
-------------------------------------------
[SEB]- X.3.(L11) frozen ports in dispatch condition must be consistent with that of
                 the core AADL model
- X.6.(20) port name only one dimension array


.expressions
-------------------------------------------
- X.7.(L22) a (L27)

[SEB]. variable
-------------------------------------------
[SEB]- X.3.(L2) local variable and persistent variable reference


.transition
-------------------------------------------
[SEB]- X.3.(L8) only transitions out of complete states may have dispatch conditions
[SEB]- X.3.(L9) transitions out of completes must have dispatch conditions
[SEB]- X.3.(L10) transitions from states that are final only are not allowed  

--------------------------------------------------------------------------------
CONSISTENCY RULES
--------------------------------------------------------------------------------

.ports
-------------------------------------------
- X.5.(C1) port input_time
- X.5.(C2) port output_time



--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
COMMENTS
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

##### C001 ####

.Object      : XXXX

.Transmit    : AADL committe on 16 May 2010

.Rules       : X.4.(21) and core AADL Language

.Description :
   - aadl-ba semantic rule 21:
     (21) A behavior annex subclause may be interpreted as a refinement of a 
     call sequence section in a thread or subprogram component implementation. 
     If both a call sequence section and a behavior annex subclause with 
     subprogram call actions are defined for the same component implementation,
     then all the subprogram calls specified in the former must be reflected in 
     the latter, although the call order may differ.

   - aadl2 core language:
     subprogram_call ::=
       defining_call_identifier : subprogram called_subprogram
       [ { { subcomponent_call_property_association }+ } ] ;

     called_subprogram ::=
       -- identification by classifier
       subprogram_unique_component_classifier_reference
     | ( data_unique_component_type_reference
         . data_provides_subprogram_access_identifier )
     | ( subprogram_group_unique_component_type_reference
         . provides_subprogram_access_identifier )
       -- identification by prototype
     | prototype_identifier
       -- identification by processor subprogram access feature
     | ( processor . provides_subprogram_access_identifier )
       -- identification by subprogram instance
     | subprogram_subcomponent_identifier
     | ( subprogram_group_subcomponent_identifier .
         provides_subprogram_access_identifier )
     | requires_subprogram_access_identifier
     | ( requires_subprogram_group_access_reference .
         provides_subprogram_access_identifier )


.Questions
  1) Are abstract components not concerned by the aadl-ba rule 21 ?


  2) How can I specify a processor_subprogram_access in a behavior 
     specification ? If we use the aadl-ba draft 2.13, the keyword processor 
     is not defined. So how can I check the consistency between component 
     implementation call sequences and subprograms used in the behavior 
     specification ? Only with the called_subprogram identifier ?

##### C001 (end) ####
